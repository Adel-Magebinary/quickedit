<?php

/**
 * @file
 * Provides inline content editing functionality for fields and entities.
 *
 * The Edit module makes content editable inline. Rather than having to visit a
 * separate page to edit content, it may be edited in-place.
 *
 * Technically, this module adds classes and data- attributes to fields and
 * entities, enabling them for in-place editing.
 */

/**
 * Implements hook_menu()
 */
function edit_menu() {
  $items = array();
  $items['edit/metadata'] = array(
    // Access is controlled after we have inspected the entity, which can't
    // easily happen until after the callback.
    'access arguments' => array(TRUE),
    'access callback' => TRUE,
    'page callback' => 'edit_metadata',
    'file' => 'includes/pages.inc',
    'delivery callback' => 'ajax_deliver',
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
  );
  $items['edit/form/%/%/%/%/%'] = array(
    // Access is controlled after we have inspected the entity, which can't
    // easily happen until after the callback.
    'access arguments' => array(TRUE),
    'access callback' => TRUE,
    'page callback' => 'edit_field_edit',
    'page arguments' => array(2, 3, 4, 5, 6),
    'file' => 'includes/pages.inc',
    'delivery callback' => 'ajax_deliver',
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
  );
  $items['edit/text/%/%/%/%/%'] = array(
    // Access is controlled after we have inspected the entity, which can't
    // easily happen until after the callback.
    'access arguments' => array(TRUE),
    'access callback' => TRUE,
    'page callback' => 'edit_text_field_render_without_transformation_filters',
    'page arguments' => array(2, 3, 4, 5, 6),
    'file' => 'includes/pages.inc',
    'delivery callback' => 'ajax_deliver',
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function edit_theme() {
  return array(
    'edit_wrap_field' => array(
      'variables' => array('value' => NULL, 'edit_id' => NULL),
    ),
  );
}

/**
 * Implements hook_library().
 */
function edit_library() {
  $path = drupal_get_path('module', 'edit');
  $options = array(
    'scope' => 'footer',
    array('weight' => 1),
  );
  $libraries['edit'] = array(
    'title' => 'Edit: in-place editing',
    'website' => 'http://drupal.org/project/edit',
    'version' => VERSION,
    'js' => array(
      // Core.
      $path . '/js/app.js' => $options,
      $path . '/js/edit.js' => array('weight' => 2) + $options,
      // Routers.
      $path . '/js/routers/edit-router.js' => $options,
      // Models.
      $path . '/js/models/edit-app-model.js' => $options,
      // Views.
      $path . '/js/views/propertyeditordecoration-view.js' => $options,
      $path . '/js/views/menu-view.js' => $options,
      $path . '/js/views/modal-view.js' => $options,
      $path . '/js/views/overlay-view.js' => $options,
      $path . '/js/views/toolbar-view.js' => $options,
      // Backbone.sync implementation on top of Drupal forms.
      $path . '/js/backbone.drupalform.js' => $options,
      // VIE service.
      $path . '/js/viejs/EditService.js' => $options,
      // Create.js subclasses.
      $path . '/js/createjs/editable.js' => $options,
      $path . '/js/createjs/storage.js' => $options,
      // Other.
      $path . '/js/util.js' => $options,
      $path . '/js/theme.js' => $options,
      // Basic settings.
      array(
        'data' => array(
          'edit' => array(
            'metadataURL' => url('edit/metadata'),
            'fieldFormURL' => url('edit/form/!entity_type/!id/!field_name/!langcode/!view_mode'),
            'rerenderProcessedTextURL' => url('edit/text/!entity_type/!id/!field_name/!langcode/!view_mode'),
            'context' => 'body',
          )
        ),
        'type' => 'setting',
      ),
    ),
    'css' => array(
      $path . '/css/edit.css' => array(),
    ),
    'dependencies' => array(
      array('system', 'jquery'),
      array('edit', 'underscore'),
      array('edit', 'backbone'),
      array('edit', 'vie.core'),
      array('edit', 'create.editonly'),
      array('system', 'jquery.form'),
      array('system', 'drupal.form'),
      array('system', 'drupal.ajax'),
    ),
  );

  $libraries['edit.editor.form'] = array(
    'title' => '"Form" Create.js PropertyEditor widget',
    'version' => VERSION,
    'js' => array(
      $path . '/js/createjs/editingWidgets/formwidget.js' => $options,
    ),
    'dependencies' => array(
      array('edit', 'edit'),
    ),
  );
  $libraries['edit.editor.direct'] = array(
    'title' => '"Direct" Create.js PropertyEditor widget',
    'version' => VERSION,
    'js' => array(
      $path . '/js/createjs/editingWidgets/drupalcontenteditablewidget.js' => $options,
    ),
    'dependencies' => array(
      array('edit', 'edit'),
    ),
  );

  if (module_exists('ckeditor')) {
    module_load_include('module', 'ckeditor');
    $libraries['edit.editor.ckeditor'] = array(
      'title' => '"CKEditor" Create.js PropertyEditor widget',
      'version' => VERSION,
      'js' => array(
        $path . '/js/createjs/editingWidgets/drupalckeditorwidget.js' => array('weight' => 3) + $options,
        drupal_get_path('module', 'ckeditor') . '/ckeditor/ckeditor.js' => array('weight' => 4) +  $options,
      ),
      'dependencies' => array(
        array('edit', 'edit'),
      ),
    );
  }

  $libraries['create.editonly'] = array(
    'title' => 'CreateJS and deps',
    'website' => 'http://createjs.org',
    'version' => NULL,
    'js' => array(
      $path . '/vendor/create/create-editonly.js' => array( /*'defer' => TRUE*/),
    ),
    'dependencies' => array(
      array('system', 'ui.widget'),
      array('edit', 'vie.core'),
    ),
  );

  $libraries['vie.core'] = array(
    'title' => 'Vienna IKS Editables',
    'website' => 'http://wiki.iks-project.eu/index.php/VIE',
    'version' => '2.0',
    'js' => array(
      $path . '/vendor/vie/vie-core.js' => array( /*'defer' => TRUE*/),
    ),
    'dependencies' => array(
      array('edit', 'backbone'),
    ),
  );

  // Register underscore as a library.
  $libraries['underscore'] = array(
    'title' => 'Underscore.js',
    'website' => 'http://underscorejs.org',
    'version' => '1.4.2',
    'js' => array(
      $path . '/vendor/underscore/underscore.js' => array(),
    ),
  );

  // Register backbone as a library.
  $libraries['backbone'] = array(
    'title' => 'Backbone.js',
    'website' => 'http://backbonejs.org',
    'version' => '0.9.2',
    'js' => array(
      $path . '/vendor/backbone/backbone.js' => array(),
    ),
    'dependencies' => array(
      array('edit', 'underscore'),
    ),
  );

  return $libraries;
}

/**
 * Implements hook_block_info().
 */
function edit_block_info() {
  $blocks['edit'] = array(
    'info' => t('Quick edit'),
    'status' => TRUE,
    'region' => 'sidebar_first',
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function edit_block_view($delta = '') {
  if ($delta === 'edit') {
    $block['subject'] = t('In-place edit operations');
    $content = '';

    $path = current_path();

    // Don't provide a view/edit toggle on admin pages, node/add and node/%/edit pages.
    if (!path_is_admin($path)) {
      $content = array(
        'content' => array(
          '#type' => 'link',
          '#title' => t('Quick edit'),
          '#href' => $path,
          '#options' => array('attributes' => array('id' => 'toolbar-tab-edit', 'class' => array('edit_view-edit-toggle', 'edit-edit'))),
          '#ajax' => array(
            'path' => 'edit/metadata',
            'event' => 'metadatafetch',
            'progress' => array(),
          ),
        ),
        '#pre_render' => array('edit_editbar_pre_render'),
      );
    }
    $block['content'] = $content;
  }

  return $block;
}

/**
 * Post-render function to remove the editbar if nothing editable is present.
 */
function edit_editbar_pre_render($content) {
  $editbar = !empty($GLOBALS['editbar']) ? $GLOBALS['editbar'] : FALSE;
  $content['#attached'] = array(
    'library' => array(array('edit', 'edit')),
  );
  if (!$editbar) {
    $content['#printed'] = TRUE;
  }
  return $content;
}


/**
 * Implements hook_preprocess_field().
 */
function edit_preprocess_field(&$variables) {
  $element = $variables['element'];

  $entity_type = $element['#entity_type'];
  $field_name = $element['#field_name'];
  $language = $element['#language'];
  $view_mode = $element['#view_mode'];
  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $element['#object']);

  // Provide metadata through data- attributes.
  $variables['attributes_array']['data-edit-id'] = "$entity_type/$id/$field_name/$language/$view_mode";
}


/**
 * Implements hook_preprocess_page().
 */
function edit_preprocess_page(&$variables) {
  // If we don't have a node object to work with, return early to avoid
  // processing.
  if (empty($variables['node'])) {
    return;
  }

  $node = $variables['node'];

  // Ensure the user has access to update the node.
  if (entity_access('update', 'node', $node)) {
    // On full node pages the title of the node becomes the page title so we
    // must handle it differently. In this case, we add a wrapper around the
    // title with the required attributes to enable editability.
    $node_type = node_type_get_type($node->type);

    if ($node_type->has_title) {
      // Make sure the editbar is created.
      $GLOBALS['editbar'] = TRUE;
      $language = !empty($node->language) ? $node->language : LANGUAGE_NONE;

      $variables['title'] = edit_wrap_pseudofield(drupal_get_title(), "node/$node->nid/title/$language/full");
    }
  }
}

/**
 * Implements hook_preprocess_node().
 */
function edit_preprocess_node(&$variables) {
  $entity_type = $variables['elements']['#entity_type'];
  $entity = $variables['elements']['#node'];
  $view_mode = $variables['elements']['#view_mode'];

  if (entity_access('update', $entity_type, $entity)) {
    // Make sure the editbar is created.
    $GLOBALS['editbar'] = TRUE;

    list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
    $language = !empty($entity->language) ? $entity->language : LANGUAGE_NONE;
    $edit_id_suffix = "$language/$view_mode";

    // Pseudo-field: title.
    $node_type = node_type_get_type($bundle);
    if ($node_type->has_title) {
      $variables['title_attributes_array']['data-edit-id'] = "node/$id/title/$edit_id_suffix";
      $variables['title'] = edit_wrap_pseudofield($entity->title, "node/$id/title/$edit_id_suffix");
    }

    // Pseudo-fields: author (name) and created date (authoring date).
    if ($variables['display_submitted']) {
      $variables['name'] = edit_wrap_pseudofield($variables['name'], "node/$id/author/$edit_id_suffix");
      $variables['date'] = edit_wrap_pseudofield($variables['date'], "node/$id/created/$edit_id_suffix");
      $variables['submitted'] = t('Submitted by !username on !datetime', array('!username' => $variables['name'], '!datetime' => $variables['date']));
    }
  }
}

/**
 * Implements hook_preprocess_panels_pane().
 */
function edit_preprocess_panels_pane(&$variables) {
  // If we don't have a node object to work with, return early to avoid
  // processing.
  // Note: This convoluted check is required because the expression
  // $variables['content']['#node'] is being interpreted as "the first character
  // of the string in $variables['content']" in panes that contain 'content' as
  // a string, rather than an array. Bleh.
  if (!isset($variables['content']['#node']) || !is_object($variables['content']['#node'])) {
    return;
  }

  $node = $variables['content']['#node'];
  $language = !empty($node->language) ? $node->language : LANGUAGE_NONE;
  $view_mode = !empty($variables['pane']->configuration['build_mode']) ? $variables['pane']->configuration['build_mode'] : 'default';
  $edit_id_suffix = "$language/$view_mode";

  // Ensure the user has access to update the node.
  if (entity_access('update', 'node', $node)) {
    // Make sure the editbar is created.
    $GLOBALS['editbar'] = TRUE;

    $node_type = node_type_get_type($node->type);
    if ($node_type->has_title) {
      //$variables['title_attributes_array']['data-edit-id'] = "node/$node->nid/title/$edit_id_suffix";

      // Title needs some special handling only show things if title is not overriden
      // and you don't have a link on the node title.
      $configuration = $variables['pane']->configuration;
      if (!$configuration['override_title']) {
        $variables['title'] = edit_wrap_pseudofield($variables['title'], "node/$node->nid/title/$edit_id_suffix");
      }
    }
  }
}

/**
 * Implements hook_ckeditor_plugin().
 *
 * Adds the sharedspaces plugin.
 */
function edit_ckeditor_plugin() {
  return array(
    'sharedspace' => array(
      // Name of the plugin used to write it.
      'name' => 'sharedspace',
      // Description of the plugin - it would be displayed in the plugins management section of profile settings.
      'desc' => t('Shared space'),
      // The full path to the CKEditor plugins directory, with the trailing slash.
      'path' => drupal_get_path('module', 'edit') . '/vendor/ckeditor/plugins/sharedspace/',
      'buttons' => FALSE,
    ),
  );
}

/**
 * Discovers all available editors by invoking hook_edit_editor_info().
 *
 * @param bool $reset
 *   Reset the editor info static cache.
 *
 * @return array
 *   An associative array keyed on editor ID.
 *
 * @see Drupal 8's Edit's EditorManager
 */
function edit_editor_list($reset = FALSE) {
  $editors = &drupal_static(__FUNCTION__, NULL);
  if (!$editors || $reset) {
    $editors = module_invoke_all('edit_editor_info');
    drupal_alter('edit_editor_info', $editors);
  }

  return $editors;
}

function edit_editor_get($editor) {
  $list = edit_editor_list();
  return !empty($list[$editor]) ? $list[$editor] : FALSE;
}

/**
 * Implements hook_edit_editor_info().
 *
 * @see Drupal 8's Edit's FormEditor and DirectEditor.
 */
function edit_edit_editor_info() {
  $editors = array();

  $editors['form'] = array(
    'widget' => 'drupalFormWidget',
    'compatibility check callback' => '_edit_editor_form_is_compatible',
    'metadata callback' => '_edit_editor_form_metadata',
    'attachments callback' => '_edit_editor_form_attachments',
    'file' => 'includes/editor.form.inc',
  );
  $editors['direct'] = array(
    'widget' => 'drupalContentEditableWidget',
    'compatibility check callback' => '_edit_editor_direct_is_compatible',
    'metadata callback' => '_edit_editor_direct_metadata',
    'attachments callback' => '_edit_editor_direct_attachments',
    'file' => 'includes/editor.direct.inc',
  );
  if (module_exists('ckeditor')) {
    $editors['ckeditor'] = array(
      'widget' => 'drupalCKEditorWidget',
      'compatibility check callback' => '_edit_editor_ckeditor_is_compatible',
      'metadata callback' => '_edit_editor_ckeditor_metadata',
      'attachments callback' => '_edit_editor_ckeditor_attachments',
      'alternativeTo' => array('direct'),
      'file' => 'includes/editor.ckeditor.inc',
    );
  }
  return $editors;
}

/**
 * Returns all editor attachments, ready for use with #attached.
 *
 * @return array
 *   The attachments.
 *
 * @see drupal_process_attached()
 * @see Drupal 8's Edit's EditorSelector::getAllEditorAttachments()
 */
function edit_get_all_editor_attachments() {
  $attachments = array();
  $editors = edit_editor_list();
  $settings = array();

  // Editor plugins' attachments.
  foreach ($editors as $editor_id => $editor) {
    if ($editor['file']) {
      $file_path = !empty($editor['file path']) ? $editor['file path'] : drupal_get_path('module', 'edit');
      require_once $file_path . '/' . $editor['file'];
    }
    $attachments[] = $editor['attachments callback']();
  }

  // JavaScript settings for Edit.
  foreach ($editors as $editor_id => $editor) {
    $settings[$editor_id] = array('widget' => $editor['widget']);
  }

  if (!empty($settings)) {
    $attachments[] = array(
      // This will be used in Create.js' propertyEditorWidgetsConfiguration.
      'js' => array(
        array(
          'type' => 'setting',
          'data' => array('edit' => array('editors' => $settings)),
        )
      ),
    );
  }

  return drupal_array_merge_deep_array($attachments);
}

/**
 * Implements hook_module_implements_alter().
 *
 * Make sure our alter hook is run after jquery update (and after all the others
 * for that matter).
 */
function edit_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'library_alter') {
    // Move our hook implementation to the bottom.
    $group = $implementations['edit'];
    unset($implementations['edit']);
    $implementations['edit'] = $group;
  }
}

/**
 * Implements hook_library_alter().
 */
function edit_library_alter(&$libraries, $module) {
  $jquery_version = &drupal_static(__FUNCTION__, NULL);
  if ($module == 'system') {
    $jquery_version = $libraries['jquery']['version'];
  }
  if ($jquery_version && $module == 'edit') {
    $path = drupal_get_path('module', 'edit');
    // Adds the minimum event API createjs needs
    if ($jquery_version < '1.7') {
      $libraries['edit']['js'][$path . '/js/ducktape.events.js'] = array('group' => JS_LIBRARY);
    }
    // If the version of jQuery is old, we need to add deferred to jquery 1.4
    if ($jquery_version < '1.5') {
      $libraries['edit']['js'][$path . '/js/ducktape.deferred.js'] = array('group' => JS_LIBRARY);
    }
  }
}

/**
 * Implements hook_field_attach_view_alter().
 */
function edit_field_attach_view_alter(&$output, $context) {
  if (!module_exists('filter_true_wysiwyg')) {
    return;
  }

  // Special case for this special mode.
  // @todo move that to filter_true_wysiwyg module?
  if ($context['display'] == 'edit-render-without-transformation-filters') {
    $children = element_children($output);
    $field = reset($children);
    $langcode = $output[$field]['#language'];
    foreach (array_keys($output[$field]['#items']) as $item) {
      $text = $output[$field]['#items'][$item]['value'];
      $format_id = $output[$field]['#items'][$item]['format'];
      $wrapped_and_untransformed = check_markup2($text, $format_id, $langcode, FALSE, array(FILTER_TYPE_TRANSFORM_DOM, FILTER_TYPE_TRANSFORM_TEXT));
      $output[$field][$item]['#markup'] = $wrapped_and_untransformed;
    }
  }
}

/**
 * Implements hook_field_formatter_info_alter().
 */
function edit_field_formatter_info_alter(&$info) {
  // Every field can use the 'form' editor, but non-rich text fields can use the
  // 'direct' editor, so we enrich the field formatter info metadata to indicate
  // this.
  if (module_exists('text')) {
    $info['text_default']['settings']['edit']['editor'] = 'direct';
    $info['text_plain']['settings']['edit']['editor'] = 'direct';
  }
}

/**
 * Wraps the name pseudo-field attached to nodes.
 *
 * @param $name
 *   The existing name value.
 * @param $node_id
 *   The node ID.
 *
 * @return
 *   The fully-themed HTML output for the wrapped "name" pseudo-field.
 */
function edit_wrap_pseudofield($value, $edit_id) {
  return theme('edit_wrap_field', array('value' => $value, 'edit_id' => $edit_id));
}

/**
 * Formats a field in a wrapper with the required metadata.
 */
function theme_edit_wrap_field($variables) {
  $variables['attributes']['data-edit-id'] = $variables['edit_id'];
  return '<span' . drupal_attributes($variables['attributes']) . '><span class="field-item">' .  $variables['value'] . '</span></span>';
}
