<?php

/**
 * @file
 * Provides inline content editing functionality for fields and entities.
 *
 * The Edit module makes content editable inline. Rather than having to visit a
 * separate page to edit content, it may be edited in-place.
 *
 * Technically, this module adds classes and data- attributes to fields and
 * entities, enabling them for in-place editing.
 */

define('EDIT_WYSIWYG_VARIABLE', 'edit_wysiwyg');
// @TODO: provide a UI so users can switch to
define('EDIT_WYSIWYG_DEFAULT', 'ckeditor');

/**
 * Implements hook_menu()
 */
function edit_menu() {
  $items = array();
  $items['edit/metadata'] = array(
    // Access is controlled after we have inspected the entity, which can't
    // easily happen until after the callback.
    'access arguments' => array(TRUE),
    'access callback' => TRUE,
    'page callback' => 'edit_metadata',
    'file' => 'includes/pages.inc',
    //'delivery callback'=> 'ajax_deliver',
    //'theme callback'   => 'ajax_base_page_theme',
  );
  $items['admin/edit/field/%/%/%/%/%'] = array(
    // Access is controlled after we have inspected the entity, which can't
    // easily happen until after the callback.
    'access arguments' => array(TRUE),
    'access callback' => TRUE,
    'page callback' => 'edit_field_edit',
    'page arguments' => array(3, 4, 5, 6, 7),
    'file' => 'includes/pages.inc',
    'delivery callback' => 'ajax_deliver',
    'theme callback' => 'ajax_base_page_theme',
  );
  $items['admin/render-without-transformations/field/%/%/%/%/%'] = array(
    // Access is controlled after we have inspected the entity, which can't
    // easily happen until after the callback.
    'access arguments' => array(TRUE),
    'access callback' => TRUE,
    'page callback' => 'edit_text_field_render_without_transformation_filters',
    'page arguments' => array(3, 4, 5, 6, 7),
    'file' => 'includes/pages.inc',
    'delivery callback' => 'ajax_deliver',
    'theme callback' => 'ajax_base_page_theme',
  );

  return $items;
}

/**
 * Implements hook_block_info().
 */
function edit_block_info() {
  $blocks['edit'] = array(
    'info' => t('Quick edit'),
    'status' => TRUE,
    'region' => 'sidebar_first', // Not usually provided.
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function edit_block_view($delta = '') {
  if ($delta === 'edit') {
    $block['subject'] = t('In-place edit operations');
    $content = '';

    $path = current_path();
    // @todo: fix http://drupal.org/node/1798458, this is a stopgap measure
    $node_only = arg(0) == 'node' && is_numeric(arg(1));

    // Don't provide a view/edit toggle on admin pages, node/add and node/%/edit pages.
    if (!path_is_admin($path) && $node_only) {
      $content = array(
        'content' => array(
          '#theme' => 'item_list',
          '#items' => array(
            l(t('View'), $path, array('attributes' => array('class' => array('edit_view-edit-toggle', 'edit-view')))),
            l(t('Quick edit'), $path, array('attributes' => array('id' => 'toolbar-tab-edit', 'class' => array('edit_view-edit-toggle', 'edit-edit')))),
          ),
        ),
        '#attached' => array(
          'library' => array(
            array('edit', 'edit'),
          ),
        ),
        '#post_render' => array(
          'edit_editbar_post_render',
        ),
      );
    }
    $block['content'] = $content;
  }

  return $block;
}

/**
 * Post-render function to remove the editbar if nothing editable is present.
 */
function edit_editbar_post_render($html) {
  return (!empty($GLOBALS['editbar']) && $GLOBALS['editbar'] !== TRUE) ? '' : $html;
}

/**
 * Implements hook_theme().
 */
function edit_theme() {
  return array(
    'edit_spanned_field' => array(
      'file' => 'includes/theme.inc',
      'variables' => array(
        'value' => NULL,
        'edit_id' => NULL,
        'label' => NULL,
        'attributes' => array(),
      ),
    ),
  );
}

/**
 * Implements hook_library().
 */
function edit_library() {
  // Figure out which library dependency to set for WYSIWYG editor integration.
  $wysiwyg_module = variable_get(EDIT_WYSIWYG_VARIABLE, EDIT_WYSIWYG_DEFAULT);
  $path = drupal_get_path('module', 'edit');
  $options = array(
    'scope' => 'footer',
    'attributes' => array('defer' => TRUE),
  );
  $libraries['edit'] = array(
    'title' => 'Edit: in-place editing',
    'website' => 'http://drupal.org/project/edit',
    'version' => VERSION,
    'js' => array(
      // Core.
      $path . '/js/app.js' => $options,
      $path . '/js/edit.js' => $options,
      // Routers.
      $path . '/js/routers/edit-router.js' => $options,
      // Models.
      $path . '/js/models/edit-app-model.js' => $options,
      // Views.
      $path . '/js/views/propertyeditordecoration-view.js' => $options,
      $path . '/js/views/menu-view.js' => $options,
      $path . '/js/views/modal-view.js' => $options,
      $path . '/js/views/overlay-view.js' => $options,
      $path . '/js/views/toolbar-view.js' => $options,
      // Backbone.sync implementation on top of Drupal forms.
      $path . '/js/backbone.drupalform.js' => $options,
      // VIE service.
      $path . '/js/viejs/EditService.js' => $options,
      // Create.js subclasses.
      $path . '/js/createjs/editable.js' => $options,
      $path . '/js/createjs/storage.js' => $options,
      $path . '/js/createjs/editingWidgets/formwidget.js' => $options,
      $path . '/js/createjs/editingWidgets/drupalcontenteditablewidget.js' => $options,
      // Other.
      $path . '/js/util.js' => $options,
      $path . '/js/theme.js' => $options,
      // Basic settings.
      array(
        'data' => array(
          'edit' => array(
            'metadataURL' => url('edit/metadata'),
            'fieldFormURL' => url('admin/edit/field/!entity_type/!id/!field_name/!langcode/!view_mode'),
            'rerenderProcessedTextURL' => url('admin/render-without-transformations/field/!entity_type/!id/!field_name/!langcode/!view_mode'),
            'context' => 'body',
          )
        ),
        'type' => 'setting',
      ),
    ),
    'css' => array(
      $path . '/css/edit.css' => array(),
    ),
    'dependencies' => array(
      array('system', 'jquery'),
      array('edit', 'underscore'),
      array('edit', 'backbone'),
      array('edit', 'vie.core'),
      array('edit', 'create.editonly'),
      array('system', 'jquery.form'),
      array('system', 'drupal.form'),
      array('system', 'drupal.ajax'),
    ),
  );

  $libraries['create.editonly'] = array(
    'title' => 'CreateJS and deps',
    'website' => 'http://createjs.org',
    'version' => NULL,
    'js' => array(
      drupal_get_path('module', 'jquery_update') . '/replace/ui/ui/jquery.ui.widget.js' => array(),
      $path . '/vendor/create/create-editonly.js' => array( /*'defer' => TRUE*/),
    ),
    'dependencies' => array(
      array('edit', 'vie.core'),
    ),
  );

  $libraries['vie.core'] = array(
    'title' => 'Vienna IKS Editables',
    'website' => 'http://wiki.iks-project.eu/index.php/VIE',
    'version' => '2.0',
    'js' => array(
      $path . '/vendor/vie/vie-core.js' => array( /*'defer' => TRUE*/),
    ),
    'dependencies' => array(
      array('edit', 'backbone'),
    ),
  );

  // Register underscore as a library.
  $libraries['underscore'] = array(
    'title' => 'Underscore.js',
    'website' => 'http://underscorejs.org',
    'version' => '1.4.2',
    'js' => array(
      $path . '/vendor/underscore/underscore.js' => array(),
    ),
  );

  // Register backbone as a library.
  $libraries['backbone'] = array(
    'title' => 'Backbone.js',
    'website' => 'http://backbonejs.org',
    'version' => '0.9.2',
    'js' => array(
      $path . '/vendor/backbone/backbone.js' => array(),
    ),
    'dependencies' => array(
      array('edit', 'underscore'),
    ),
  );

  // Only add dependencies on the WYSIWYG editor when it's actually available.
  if (module_exists($wysiwyg_module)) {
    $libraries['edit']['dependencies'][] = array($wysiwyg_module, "$wysiwyg_module.edit");
  }

  return $libraries;
}

/**
 * Implements hook_field_attach_view_alter().
 */
function edit_field_attach_view_alter(&$output, $context) {
  if (!module_exists('filter_true_wysiwyg')) {
    return;
  }

  // Special case for this special mode.
  if ($context['display'] == 'edit-render-without-transformation-filters') {
    $children = element_children($output);
    $field = reset($children);
    $langcode = $output[$field]['#language'];
    foreach (array_keys($output[$field]['#items']) as $item) {
      $text = $output[$field]['#items'][$item]['value'];
      $format_id = $output[$field]['#items'][$item]['format'];
      $wrapped_and_untransformed = check_markup2($text, $format_id, $langcode, FALSE, array(FILTER_TYPE_TRANSFORM_DOM, FILTER_TYPE_TRANSFORM_TEXT));
      $output[$field][$item]['#markup'] = $wrapped_and_untransformed;
    }
  }
}

/**
 * Implements hook_field_formatter_info_alter().
 */
function edit_field_formatter_info_alter(&$info) {
  // @todo Create a UI that allows users to override these defaults.

  // Add a new "edit" property to each formatter, which contains metadata for
  // the Edit module depending on the formatter. It contains the following keys:
  //   * 'editability', with one of the following values:
  //     - 'editable': these fields will be immediately editable.
  //     - 'form': these fields will load the field's form through AJAX.
  //     - 'disabled': these fields will not be editable inline.
  //   * 'wysiwyg', with boolean values
  $editability_metadata = array(
    // @todo Implement file and image editability.
    'file_default' => 'form',
    'file_table' => 'form',
    'file_url_plain' => 'disabled',
    'image' => 'form',
    'list_default' => 'form',
    'list_key' => 'form',
    'number_integer' => 'form',
    'number_decimal' => 'form',
    'number_unformatted' => 'form',
    'taxonomy_term_reference_link' => 'form',
    'taxonomy_term_reference_plain' => 'form',
    'taxonomy_term_reference_rss_category' => 'disabled',
    'text_default' => 'direct',
    'text_plain' => 'form',
    'text_trimmed' => 'disabled',
    'text_summary_or_trimmed' => 'disabled',
    'text_textarea' => 'direct',
  );
  $wysiwyg_metadata = array(
    'text_default' => TRUE,
    'text_plain' => FALSE,
  );
  foreach ($editability_metadata as $formatter => $editability) {
    if (!empty($info[$formatter])) {
      $info[$formatter]['settings']['edit'] = array(
        'editability' => $editability,
        'wysiwyg' => (isset($wysiwyg_metadata[$formatter])) ? $wysiwyg_metadata[$formatter] : FALSE,
      );
    }
  }
}

/**
 * Implements hook_preprocess_panels_pane().
 */
function edit_preprocess_panels_pane(&$variables) {
  // If we don't have a node object to work with, return early to avoid
  // processing.
  // Note: This convoluted check is required because the expression
  // $variables['content']['#node'] is being interpreted as "the first character
  // of the string in $variables['content']" in panes that contain 'content' as
  // a string, rather than an array. Bleh.
  if (!isset($variables['content']['#node']) || !is_object($variables['content']['#node'])) {
    return;
  }

  $node = $variables['content']['#node'];
  $language = $node->language;
  // @todo make it work
  $view_mode = 'default';

  // Ensure the user has access to update the node.
  if (entity_access('update', 'node', $node)) {
    // Make sure the editbar is created.
    $GLOBALS['editbar'] = TRUE;

    $node_type = node_type_get_type($node->type);
    if ($node_type->has_title) {
      $variables['title_attributes_array']['class'][] = 'edit-pseudofield';
      $variables['title_attributes_array']['class'][] = 'edit-field';
      $variables['title_attributes_array']['class'][] = 'edit-allowed';
      $variables['title_attributes_array']['class'][] = 'edit-type-direct';
      $variables['title_attributes_array']['data-edit-field-label'] = $node_type->title_label;
      $variables['title_attributes_array']['data-edit-id'] = "node:$node->nid:title:$language:$view_mode";
    }
  }
}

/**
 * Implements hook_preprocess_page().
 */
function edit_preprocess_page(&$variables) {
  // If we don't have a node object to work with, return early to avoid
  // processing.
  if (empty($variables['node'])) {
    return;
  }

  $node = $variables['node'];

  // Ensure the user has access to update the node.
  if (entity_access('update', 'node', $node)) {
    // On full node pages the title of the node becomes the page title so we
    // must handle it differently. In this case, we add a wrapper around the
    // title with the required attributes to enable editability.
    $node_type = node_type_get_type($node->type);

    if ($node_type->has_title) {
      // Make sure the editbar is created.
      $GLOBALS['editbar'] = TRUE;

      $variables['title'] = edit_page_title_render(drupal_get_title(), $node_type->title_label, $node->nid);
    }
  }
}

/**
 * Implements hook_preprocess_node().
 */
function edit_preprocess_node(&$variables) {
  $entity_type = $variables['elements']['#entity_type'];
  $entity = $variables['elements']['#node'];
  $view_mode = $variables['elements']['#view_mode'];

  if (entity_access('update', $entity_type, $entity)) {
    // Make sure the editbar is created.
    $GLOBALS['editbar'] = TRUE;

    list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
    $language = $entity->language;
    // Pseudo-field: title.
    $node_type = node_type_get_type($bundle);
    if ($node_type->has_title) {
      $variables['title_attributes_array']['class'][] = 'edit-pseudofield';
      $variables['title_attributes_array']['class'][] = 'edit-field';
      $variables['title_attributes_array']['class'][] = 'edit-allowed';
      $variables['title_attributes_array']['class'][] = 'edit-type-direct';
      $variables['title_attributes_array']['data-edit-field-label'] = $node_type->title_label;
      $variables['title_attributes_array']['data-edit-id'] = "node:$id:title:$language:$view_mode";
    }

    // Pseudo-fields: author (name) and created date (authoring date).
    if ($variables['display_submitted']) {
      $variables['name'] = edit_node_wrap_name($variables['name'], $id, $language, $view_mode);
      $variables['date'] = edit_node_wrap_date($variables['date'], $id, $language, $view_mode);
      $variables['submitted'] = edit_node_render_submitted($variables['name'], $variables['date'], $language, $view_mode);
    }
  }
}

/**
 * Wraps the name pseudo-field attached to nodes.
 *
 * @param $name
 *   The existing name value.
 * @param $node_id
 *   The node ID.
 *
 * @return
 *   The fully-themed HTML output for the wrapped "name" pseudo-field.
 */
function edit_node_wrap_name($name, $node_id, $language, $view_mode) {
  return theme('edit_spanned_field', array(
    'value' => $name,
    'label' => t('Author'),
    'edit_id' => "node:$node_id:author:$language:$view_mode",
    'attributes' => array(
      'class' => array(
        'edit-pseudofield',
        'edit-field',
        'edit-allowed',
        'edit-type-form',
      ),
    ),
  ));
}

/**
 * Wraps the "date" pseudo-field attached to nodes.
 *
 * @param $date
 *   The existing date value.
 * @param $node_id
 *   The node ID.
 *
 * @return
 *   The fully-themed HTML output for the wrapped "date" pseudo-field.
 */
function edit_node_wrap_date($date, $node_id, $language, $view_mode) {
  return theme('edit_spanned_field', array(
    'value' => $date,
    'label' => t('Authoring date'),
    'edit_id' => "node:$node_id:created:$language:$view_mode",
    'attributes' => array(
      'class' => array(
        'edit-pseudofield',
        'edit-field',
        'edit-allowed',
        'edit-type-form',
      ),
    ),
  ));
}

/**
 * Wraps the "title" pseudo-field for a page.
 *
 * @param $title
 *   The existing date value.
 * @param $label
 *   The Label name for the content type.
 * @param $node_id
 *   The node ID.
 *
 * @return
 *   The fully-themed HTML output for the wrapped "date" pseudo-field.
 */
function edit_page_title_render($title, $label, $node_id, $language = LANGUAGE_NONE) {
  return theme('edit_spanned_field', array(
    'value' => $title,
    'label' => $label,
    'edit_id' => 'node:' . $node_id . ':title:' . $language . ':full',
    'attributes' => array(
      'class' => array(
        'edit-pseudofield',
        'edit-field',
        'edit-allowed',
        'edit-type-direct',
      ),
    ),
  ));
}

/**
 * Renders the author and created date pseudo-fields.
 */
function edit_node_render_submitted($author, $created, $language, $view_mode) {
  // @todo Consider using template_preprocess_node() or theme_preprocess_node()
  // instead so this may be more easily overridden.
  return t('Submitted by !username on !datetime', array(
    '!username' => $author,
    '!datetime' => $created
  ));
}

/**
 * Implements hook_preprocess_field().
 */
function edit_preprocess_field(&$variables) {
  $element = $variables['element'];

  $entity_type = $element['#entity_type'];
  $field_name = $element['#field_name'];
  $language = $element['#language'];
  $view_mode = $element['#view_mode'];
  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $element['#object']);

  // Provide metadata through data- attributes.
  $variables['attributes_array']['data-edit-id'] = "$entity_type:$id:$field_name:$language:$view_mode";
}
