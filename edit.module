<?php

/**
 * @file
 * Provides inline content editing functionality for fields and entities.
 *
 * The Edit module makes content editable inline. Rather than having to visit a
 * separate page to edit content, it may be edited in-place.
 *
 * Technically, this module adds classes and data- attributes to fields and
 * entities, enabling them for in-place editing.
 */

/**
 * Loads the logic for altering the toolbar.
 */
module_load_include('inc', 'edit', 'includes/toolbar');

/**
 * Implements hook_menu()
 */
function edit_menu() {
  $items = array();
  $items['admin/edit/field/%/%/%'] = array(
    // Access is controlled after we have inspected the entity, which can't
    // easily happen until after the callback.
    'access arguments' => array(TRUE),
    'access callback'  => TRUE,
    'page callback'    => 'edit_field_edit',
    'page arguments'   => array(3, 4, 5),
    'file'             => 'includes/pages.inc',
    'delivery callback'=> 'ajax_deliver',
    'theme callback'   => 'ajax_base_page_theme',
  );
  return $items;
}

/**
 * Implements hook_theme().
 */
function edit_theme() {
  return array(
    'edit_spanned_field' => array(
      'file' => 'includes/theme.inc',
      'variables' => array(
        'value' => NULL,
        'edit_id' => NULL,
        'label' => NULL,
        'attributes' => array(),
      ),
    ),
  );
}

/**
 * Implements hook_library().
 */
function edit_library() {
  $path = drupal_get_path('module', 'edit');
  $libraries['edit'] = array(
    'title' => 'Edit',
    'website' => 'http://drupal.org/project/edit',
    'version' => NULL, // @todo Figure out the correct way to do this.
    'js' => array(
      $path . '/js/edit.js' => array(
        // @todo Make sure that a subset of the JavaScript is loaded ASAP, so
        // that the view/edit mode toggle works immediately.
        'defer' => TRUE,
      ),
      $path . '/js/util.js' => array(
        'defer' => TRUE,
      ),
      $path . '/js/ui.js' => array(
        'defer' => TRUE,
      ),
      $path . '/js/ui-editables.js' => array(
        'defer' => TRUE,
      ),
      $path . '/js/theme.js' => array(
        'defer' => TRUE,
      ),
      $path . '/js/ajax.js' => array(
        'defer' => TRUE,
      ),
      // Basic settings.
      array(
        'data' => array('edit' => array(
          'fieldFormURL' => url('admin/edit/field/!entity_type/!id/!field_name'),
          'context' => 'body',
        )),
        'type' => 'setting',
      ),
    ),
    'css' => array(
      $path . '/css/edit.css',
    ),
    'dependencies' => array(
      array('system', 'jquery.form'),
      array('system', 'drupal.ajax'),
    ),
  );

  return $libraries;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function edit_form_fape_field_edit_form_alter(&$form, &$form_state) {
  // Only alter this form when it's being built by the Edit module.
  if (!array_key_exists('edit', $form_state)) {
    return;
  }

  // Simplify simple field forms that contain only one form item.
  // @todo Somehow make this less hacky.
  $elements = element_children($form);
  $defaults = array('actions', 'form_build_id', 'form_token', 'form_id');
  $form_items = array_diff($elements, $defaults);
  if (count($form_items) == 1) {
    $k = $form_items[0];
    if ($form[$k]['#type'] == 'container') {
      $l = $form[$k]['#language'];
      switch (count(element_children($form[$k][$l]))) {
        case 0:
          if ($form[$k][$l]['#type'] != 'checkbox') {
            unset($form[$k][$l]['#title']);
          }
          break;
        case 1:
          unset($form[$k][$l][0]['value']['#title']);
          break;
        default:
          // No changes.
          break;
      }
    }
    // Pseudo-fields that are language-independent, such as title, name and date.
    else if (!array_key_exists('#language', $form[$k])) {
      unset($form[$k]['#title']);
    }
  }

  // Make it easy for the JavaScript to identify the submit button.
  $form['actions']['submit']['#attributes'] = array('class' => array('edit-form-submit'));
}

/**
 * Implements hook_field_formatter_info_alter().
 */
function edit_field_formatter_info_alter(&$info) {
  // @todo Create a UI that allows users to override these defaults.

  // Add a new "edit" property to each formatter, with one of the following
  // values:
  //   - 'editable': these fields will be immediately editable.
  //   - 'form': these fields will load the field's form through AJAX.
  //   - 'disabled': these fields will not be editable inline.
  $a = array(
    // @todo Implement file and image editability.
    'file_default'   => 'disabled',
    'file_table'     => 'disabled',
    'file_url_plain' => 'disabled',
    'image'          => 'disabled',
    'list_default'   => 'form',
    'list_key'       => 'form',
    'number_integer'     => 'form',
    'number_decimal'     => 'form',
    'number_unformatted' => 'form',
    'taxonomy_term_reference_link'         => 'form',
    'taxonomy_term_reference_plain'        => 'form',
    'taxonomy_term_reference_rss_category' => 'disabled',
    'text_default'            => 'direct',
    'text_plain'              => 'form',
    'text_trimmed'            => 'disabled',
    'text_summary_or_trimmed' => 'disabled',
  );
  foreach ($a as $k => $v) {
    if (array_key_exists($k, $info)) {
      $info[$k]['edit'] = $v;
    }
  }
}

/**
 * Implements hook_preprocess_page().
 */
function edit_preprocess_page(&$variables) {
  // Special case: on node pages, the title of the node becomes the page title.
  if (!empty($variables['node']) && entity_access('update', 'node', $variables['node'])) {
    // Pseudo-field: title.
    $node_type = node_type_get_type($variables['node']->type);

    if ($node_type->has_title) {
      $id = $variables['node']->nid;
      $attributes = array(
        'class' => array(
          'edit-pseudofield',
          'edit-field',
          'edit-allowed',
          'edit-type-direct',
        ),
        'data-edit-field-label' => $node_type->title_label,
        'data-edit-id' => "node:$id:title",
      );
      $variables['title_prefix']['edit']['#markup'] = '<div' . drupal_attributes($attributes) . '>';
      $variables['title_suffix']['edit']['#markup'] = '</div>';
    }
  }
}

/**
 * Implements hook_preprocess_node().
 */
function edit_preprocess_node(&$variables) {
  $entity_type = $variables['elements']['#entity_type'];
  $entity      = $variables['elements']['#node'];

  if (entity_access('update', $entity_type, $entity)) {
    list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
    $i = entity_get_info($entity_type);

    // Provide metadata using data- attributes.
    $data_attributes = array(
      'data-edit-id'              => "node:$id",
      'data-edit-entity-label'    => $i['bundles'][$bundle]['label'],
      'data-edit-entity-edit-url' => url("node/$id/edit"),
    );
    $variables['attributes_array'] += $data_attributes;

    // Mark this entity as editable.
    $variables['classes_array'][] = 'edit-entity';
    $variables['classes_array'][] = 'edit-allowed';

    // Pseudo-field: title.
    $node_type = node_type_get_type($bundle);
    if ($node_type->has_title) {
      $variables['title_attributes_array']['class'][] = 'edit-pseudofield';
      $variables['title_attributes_array']['class'][] = 'edit-field';
      $variables['title_attributes_array']['class'][] = 'edit-allowed';
      $variables['title_attributes_array']['class'][] = 'edit-type-direct';
      $variables['title_attributes_array']['data-edit-field-label'] = $node_type->title_label;
      $variables['title_attributes_array']['data-edit-id'] = "node:$id:title";
    }

    // Pseudo-fields: author (name) and created date (authoring date).
    if ($variables['display_submitted']) {
      $variables['name'] = edit_node_wrap_name($variables['name'], $id);
      $variables['date'] = edit_node_wrap_date($variables['date'], $id);
      $variables['submitted'] = edit_node_render_submitted($variables['name'], $variables['date']);
    }
  }
}

/**
 * Wraps the name pseudo-field attached to nodes.
 *
 * @param $name
 *   The existing name value.
 * @param $node_id
 *   The node ID.
 *
 * @return
 *   The fully-themed HTML output for the wrapped "name" pseudo-field.
 */
function edit_node_wrap_name($name, $node_id) {
  return theme('edit_spanned_field', array(
    'value' => $name,
    'label' => t('Author'),
    'edit_id' => "node:$node_id:author",
    'attributes' => array(
      'class' => array(
        'edit-pseudofield',
        'edit-field',
        'edit-allowed',
        'edit-type-form',
      ),
    ),
  ));
}

/**
 * Wraps the "date" pseudo-field attached to nodes.
 *
 * @param $date
 *   The existing date value.
 * @param $node_id
 *   The node ID.
 *
 * @return
 *   The fully-themed HTML output for the wrapped "date" pseudo-field.
 */
function edit_node_wrap_date($date, $node_id) {
  return theme('edit_spanned_field', array(
    'value' => $date,
    'label' => t('Authoring date'),
    'edit_id' => "node:$node_id:created",
    'attributes' => array(
      'class' => array(
        'edit-pseudofield',
        'edit-field',
        'edit-allowed',
        'edit-type-form',
      ),
    ),
  ));
}

/**
 * Renders the author and created date pseudo-fields.
 */
function edit_node_render_submitted($author, $created) {
  // @todo Consider using template_preprocess_node() or theme_preprocess_node()
  // instead so this may be more easily overridden.
  return t(
    'Submitted by !username on !datetime',
    array('!username' => $author, '!datetime' => $created)
  );
}

/**
 * Implements hook_preprocess_field().
 */
function edit_preprocess_field(&$variables) {
  $entity_type = $variables['element']['#entity_type'];
  $entity      = $variables['element']['#object'];
  $field_name  = $variables['element']['#field_name'];
  $formatter   = $variables['element']['#formatter'];

  $formatter_info = field_info_formatter_types($formatter);
  if (empty($formatter_info['edit'])) {
    // Formatter not yet compatible with Edit module.
    return;
  }
  $edit_ability = $formatter_info['edit'];
  if ($edit_ability == 'disabled') {
    return;
  }

  // If directly editable, check the cardinality. If the cardinality is greater
  // than 1, use a form to edit the field.
  if ($edit_ability == 'direct') {
    $field_info = field_info_field($field_name);
    if ($field_info['cardinality'] != 1) {
      $edit_ability = 'form';
    }
  }

  if (entity_access('update', $entity_type, $entity) && field_access('edit', $field_name, $entity_type, $entity)) {
    list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
    $ei = entity_get_info($entity_type);
    $fi = field_info_instance($entity_type, $field_name, $bundle);

    // Provide metadata through data- attributes.
    $data_attributes = array(
      'data-edit-field-label'    => $fi['label'],
      'data-edit-id'             => "$entity_type:$id:$field_name",
    );
    if (empty($variables['attributes_array'])) {
      $variables['attributes_array'] = array();
    }
    $variables['attributes_array'] += $data_attributes;

    // Mark this field as editable.
    $variables['classes_array'][] = 'edit-field';
    $variables['classes_array'][] = 'edit-allowed';
    $variables['classes_array'][] = 'edit-type-' . $edit_ability;
  }
}

