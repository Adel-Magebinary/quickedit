<?php

/**
 * @file
 * Provides inline content editing functionality for fields and entities.
 *
 * The Edit module makes content editable inline. Rather than having to visit a
 * separate page to edit content, it may be edited in-place.
 *
 * Technically, this module adds classes and data- attributes to fields and
 * entities, enabling them for in-place editing.
 */

/**
 * Implements hook_menu()
 */
function edit_menu() {
  $items = array();
  $items['edit/metadata'] = array(
    // Access is controlled after we have inspected the entity, which can't
    // easily happen until after the callback.
    'access arguments' => array(TRUE),
    'access callback' => TRUE,
    'page callback' => 'edit_metadata',
    'file' => 'includes/pages.inc',
  );
  $items['edit/form/%/%/%/%/%'] = array(
    // Access is controlled after we have inspected the entity, which can't
    // easily happen until after the callback.
    'access arguments' => array(TRUE),
    'access callback' => TRUE,
    'page callback' => 'edit_field_edit',
    'page arguments' => array(2, 3, 4, 5, 6),
    'file' => 'includes/pages.inc',
    'delivery callback' => 'ajax_deliver',
    'theme callback' => 'ajax_base_page_theme',
  );
  $items['edit/text/%/%/%/%/%'] = array(
    // Access is controlled after we have inspected the entity, which can't
    // easily happen until after the callback.
    'access arguments' => array(TRUE),
    'access callback' => TRUE,
    'page callback' => 'edit_text_field_render_without_transformation_filters',
    'page arguments' => array(2, 3, 4, 5, 6),
    'file' => 'includes/pages.inc',
    'delivery callback' => 'ajax_deliver',
    'theme callback' => 'ajax_base_page_theme',
  );

  return $items;
}

/**
 * Discovers all available editors by invoking hook_edit_editor_info().
 *
 * @param bool $reset
 *   Reset the editor info static cache.
 *
 * @return array
 *   An associative array keyed on editor ID.
 *
 * @see Drupal 8's Edit's EditorManager
 */
function edit_editor_list($reset = FALSE) {
  $editors = &drupal_static(__FUNCTION__);
  if (!isset($editors) || $reset) {
    $editors = module_invoke_all('edit_editor_info');
    drupal_alter('edit_editor_info', $editors);
  }

  return $editors;
}

/**
 * Implements hook_edit_editor_info().
 *
 * @see Drupal 8's Edit's FormEditor and DirectEditor.
 */
function edit_edit_editor_info() {
  $editors = array();

  $path = drupal_get_path('module', 'edit');

  $editors['form'] = array(
    'jsClassName' => 'drupalFormWidget',
    'file' => $path . '/includes/editor.form.inc',
    'compatibility check callback' => '_edit_editor_form_is_compatible',
    'metadata callback' => '_edit_editor_form_metadata',
    'attachments callback' => '_edit_editor_form_attachments',
  );
  $editors['direct'] = array(
    'jsClassName' => 'drupalContentEditableWidget',
    'file' => $path . '/includes/editor.direct.inc',
    'compatibility check callback' => '_edit_editor_direct_is_compatible',
    'metadata callback' => '_edit_editor_direct_metadata',
    'attachments callback' => '_edit_editor_direct_attachments',
  );

  return $editors;
}

/**
 * Implements hook_block_info().
 */
function edit_block_info() {
  $blocks['edit'] = array(
    'info' => t('Quick edit'),
    'status' => TRUE,
    'region' => 'sidebar_first',
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function edit_block_view($delta = '') {
  if ($delta === 'edit') {
    $block['subject'] = t('In-place edit operations');
    $content = '';

    $path = current_path();
    // @todo: fix http://drupal.org/node/1798458, this is a stopgap measure
    $node_only = arg(0) == 'node' && is_numeric(arg(1));

    // Don't provide a view/edit toggle on admin pages, node/add and node/%/edit pages.
    if (!path_is_admin($path) && $node_only) {
      $content = array(
        'content' => array(
          '#theme' => 'item_list',
          '#items' => array(
            l(t('View'), $path, array('attributes' => array('class' => array('edit_view-edit-toggle', 'edit-view')))),
            l(t('Quick edit'), $path, array('attributes' => array('id' => 'toolbar-tab-edit', 'class' => array('edit_view-edit-toggle', 'edit-edit')))),
          ),
        ),
        '#attached' => array(
          'library' => array(
            array('edit', 'edit'),
          ),
        ),
        '#post_render' => array(
          'edit_editbar_post_render',
        ),
      );

      // Include the attachments and settings for all available editors.
      $content['#attached'] = array_merge_recursive($content['#attached'], edit_get_all_editor_attachments());
    }
    $block['content'] = $content;
  }

  return $block;
}

/**
 * Returns all editor attachments, ready for use with #attached.
 *
 * @return array
 *   The attachments.
 *
 * @see drupal_process_attached()
 * @see Drupal 8's Edit's EditorSelector::getAllEditorAttachments()
 */
function edit_get_all_editor_attachments() {
    $attachments = array();
    $editors = edit_editor_list();

    // Editor plugins' attachments.
    foreach ($editors as $editor_id => $editor) {
      require_once($editor['file']);
      $get_attachments = $editor['attachments callback'];
      $attachments[] = $get_attachments();
    }

    // JavaScript settings for Edit.
    foreach ($editors as $editor_id => $editor) {
      $attachments[] = array(
        // This will be used in Create.js' propertyEditorWidgetsConfiguration.
        'js' => array(
          array(
            'type' => 'setting',
            'data' => array('edit' => array('editors' => array(
              $editor_id => array('widget' => $editor['jsClassName'])
            )))
          )
        )
      );
    }

    return drupal_array_merge_deep_array($attachments);
}

/**
 * Post-render function to remove the editbar if nothing editable is present.
 */
function edit_editbar_post_render($html) {
  return (!empty($GLOBALS['editbar']) && $GLOBALS['editbar'] !== TRUE) ? '' : $html;
}

/**
 * Implements hook_theme().
 */
function edit_theme() {
  return array(
    'edit_spanned_field' => array(
      'file' => 'includes/theme.inc',
      'variables' => array(
        'value' => NULL,
        'edit_id' => NULL,
        'label' => NULL,
        'attributes' => array(),
      ),
    ),
  );
}

/**
 * Implements hook_library().
 */
function edit_library() {
  $path = drupal_get_path('module', 'edit');
  $options = array(
    'scope' => 'footer',
    'attributes' => array('defer' => TRUE),
  );
  $libraries['edit'] = array(
    'title' => 'Edit: in-place editing',
    'website' => 'http://drupal.org/project/edit',
    'version' => VERSION,
    'js' => array(
      // Core.
      $path . '/js/app.js' => $options,
      $path . '/js/edit.js' => $options,
      // Routers.
      $path . '/js/routers/edit-router.js' => $options,
      // Models.
      $path . '/js/models/edit-app-model.js' => $options,
      // Views.
      $path . '/js/views/propertyeditordecoration-view.js' => $options,
      $path . '/js/views/menu-view.js' => $options,
      $path . '/js/views/modal-view.js' => $options,
      $path . '/js/views/overlay-view.js' => $options,
      $path . '/js/views/toolbar-view.js' => $options,
      // Backbone.sync implementation on top of Drupal forms.
      $path . '/js/backbone.drupalform.js' => $options,
      // VIE service.
      $path . '/js/viejs/EditService.js' => $options,
      // Create.js subclasses.
      $path . '/js/createjs/editable.js' => $options,
      $path . '/js/createjs/storage.js' => $options,
      // Other.
      $path . '/js/util.js' => $options,
      $path . '/js/theme.js' => $options,
      // Basic settings.
      array(
        'data' => array(
          'edit' => array(
            'metadataURL' => url('edit/metadata'),
            'fieldFormURL' => url('edit/form/!entity_type/!id/!field_name/!langcode/!view_mode'),
            'rerenderProcessedTextURL' => url('edit/text/!entity_type/!id/!field_name/!langcode/!view_mode'),
            'context' => 'body',
          )
        ),
        'type' => 'setting',
      ),
    ),
    'css' => array(
      $path . '/css/edit.css' => array(),
    ),
    'dependencies' => array(
      array('system', 'jquery'),
      array('edit', 'underscore'),
      array('edit', 'backbone'),
      array('edit', 'vie.core'),
      array('edit', 'create.editonly'),
      array('system', 'jquery.form'),
      array('system', 'drupal.form'),
      array('system', 'drupal.ajax'),
    ),
  );

  $libraries['edit.editor.form'] = array(
    'title' => '"Form" Create.js PropertyEditor widget',
    'version' => VERSION,
    'js' => array(
      $path . '/js/createjs/editingWidgets/formwidget.js' => $options,
    ),
    'dependencies' => array(
      array('edit', 'edit'),
    ),
  );
  $libraries['edit.editor.direct'] = array(
    'title' => '"Direct" Create.js PropertyEditor widget',
    'version' => VERSION,
    'js' => array(
      $path . '/js/createjs/editingWidgets/drupalcontenteditablewidget.js' => $options,
    ),
    'dependencies' => array(
      array('edit', 'edit'),
    ),
  );

  $libraries['create.editonly'] = array(
    'title' => 'CreateJS and deps',
    'website' => 'http://createjs.org',
    'version' => NULL,
    'js' => array(
      $path . '/vendor/create/create-editonly.js' => array( /*'defer' => TRUE*/),
    ),
    'dependencies' => array(
      array('system', 'ui.widget'),
      array('edit', 'vie.core'),
    ),
  );

  $libraries['vie.core'] = array(
    'title' => 'Vienna IKS Editables',
    'website' => 'http://wiki.iks-project.eu/index.php/VIE',
    'version' => '2.0',
    'js' => array(
      $path . '/vendor/vie/vie-core.js' => array( /*'defer' => TRUE*/),
    ),
    'dependencies' => array(
      array('edit', 'backbone'),
    ),
  );

  // Register underscore as a library.
  $libraries['underscore'] = array(
    'title' => 'Underscore.js',
    'website' => 'http://underscorejs.org',
    'version' => '1.4.2',
    'js' => array(
      $path . '/vendor/underscore/underscore.js' => array(),
    ),
  );

  // Register backbone as a library.
  $libraries['backbone'] = array(
    'title' => 'Backbone.js',
    'website' => 'http://backbonejs.org',
    'version' => '0.9.2',
    'js' => array(
      $path . '/vendor/backbone/backbone.js' => array(),
    ),
    'dependencies' => array(
      array('edit', 'underscore'),
    ),
  );

  return $libraries;
}

/**
 * Implements hook_module_implements_alter().
 *
 * Make sure our alter hook is run after jquery update (and after all the others
 * for that matter).
 */
function edit_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'library_alter') {
    // Move our hook implementation to the bottom.
    $group = $implementations['edit'];
    unset($implementations['edit']);
    $implementations['edit'] = $group;
  }
}

/**
 * Implements hook_library_alter().
 */
function edit_library_alter(&$libraries, $module) {
  $jquery_version = &drupal_static(__FUNCTION__, NULL);
  if ($module == 'system') {
    $jquery_version = $libraries['jquery']['version'];
  }
  if ($jquery_version && $module == 'edit') {
    $path = drupal_get_path('module', 'edit');
    // Adds the minimum event API createjs needs
    if ($jquery_version < '1.7') {
      $libraries['edit']['js'][$path . '/js/ducktape.events.js'] = array('group' => JS_LIBRARY);
    }
    // If the version of jQuery is old, we need to add deferred to jquery 1.4
    if ($jquery_version < '1.5') {
      $libraries['edit']['js'][$path . '/js/ducktape.deferred.js'] = array('group' => JS_LIBRARY);
    }
  }
}

/**
 * Implements hook_field_attach_view_alter().
 */
function edit_field_attach_view_alter(&$output, $context) {
  if (!module_exists('filter_true_wysiwyg')) {
    return;
  }

  // Special case for this special mode.
  if ($context['display'] == 'edit-render-without-transformation-filters') {
    $children = element_children($output);
    $field = reset($children);
    $langcode = $output[$field]['#language'];
    foreach (array_keys($output[$field]['#items']) as $item) {
      $text = $output[$field]['#items'][$item]['value'];
      $format_id = $output[$field]['#items'][$item]['format'];
      $wrapped_and_untransformed = check_markup2($text, $format_id, $langcode, FALSE, array(FILTER_TYPE_TRANSFORM_DOM, FILTER_TYPE_TRANSFORM_TEXT));
      $output[$field][$item]['#markup'] = $wrapped_and_untransformed;
    }
  }
}

/**
 * Implements hook_field_formatter_info_alter().
 */
function edit_field_formatter_info_alter(&$info) {
  // Every field can use the 'form' editor, but non-rich text fields can use the
  // 'direct' editor, so we enrich the field formatter info metadata to indicate
  // this.
  if (module_exists('text')) {
    $info['text_default']['settings']['edit']['editor'] = 'direct';
    $info['text_plain']['settings']['edit']['editor'] = 'direct';
  }
}

/**
 * Implements hook_preprocess_panels_pane().
 */
function edit_preprocess_panels_pane(&$variables) {
  // If we don't have a node object to work with, return early to avoid
  // processing.
  // Note: This convoluted check is required because the expression
  // $variables['content']['#node'] is being interpreted as "the first character
  // of the string in $variables['content']" in panes that contain 'content' as
  // a string, rather than an array. Bleh.
  if (!isset($variables['content']['#node']) || !is_object($variables['content']['#node'])) {
    return;
  }

  $node = $variables['content']['#node'];
  $language = !empty($node->language) ? $node->language : LANGUAGE_NONE;
  // @todo make it work
  $view_mode = 'default';

  // Ensure the user has access to update the node.
  if (entity_access('update', 'node', $node)) {
    // Make sure the editbar is created.
    $GLOBALS['editbar'] = TRUE;

    $node_type = node_type_get_type($node->type);
    if ($node_type->has_title) {
      $variables['title_attributes_array']['data-edit-id'] = "node/$node->nid/title/$language/$view_mode";
    }
  }
}

/**
 * Implements hook_preprocess_page().
 */
function edit_preprocess_page(&$variables) {
  // If we don't have a node object to work with, return early to avoid
  // processing.
  if (empty($variables['node'])) {
    return;
  }

  $node = $variables['node'];

  // Ensure the user has access to update the node.
  if (entity_access('update', 'node', $node)) {
    // On full node pages the title of the node becomes the page title so we
    // must handle it differently. In this case, we add a wrapper around the
    // title with the required attributes to enable editability.
    $node_type = node_type_get_type($node->type);

    if ($node_type->has_title) {
      // Make sure the editbar is created.
      $GLOBALS['editbar'] = TRUE;

      $variables['title'] = edit_page_title_render(drupal_get_title(), $node_type->title_label, $node->nid);
    }
  }
}

/**
 * Implements hook_preprocess_node().
 */
function edit_preprocess_node(&$variables) {
  $entity_type = $variables['elements']['#entity_type'];
  $entity = $variables['elements']['#node'];
  $view_mode = $variables['elements']['#view_mode'];

  if (entity_access('update', $entity_type, $entity)) {
    // Make sure the editbar is created.
    $GLOBALS['editbar'] = TRUE;

    list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
    $language = !empty($entity->language) ? $entity->language : LANGUAGE_NONE;
    // Pseudo-field: title.
    $node_type = node_type_get_type($bundle);
    if ($node_type->has_title) {
      $variables['title_attributes_array']['data-edit-id'] = "node/$id/title/$language/$view_mode";
    }

    // Pseudo-fields: author (name) and created date (authoring date).
    if ($variables['display_submitted']) {
      $variables['name'] = edit_node_wrap_name($variables['name'], $id, $language, $view_mode);
      $variables['date'] = edit_node_wrap_date($variables['date'], $id, $language, $view_mode);
      $variables['submitted'] = edit_node_render_submitted($variables['name'], $variables['date'], $language, $view_mode);
    }
  }
}

/**
 * Wraps the name pseudo-field attached to nodes.
 *
 * @param $name
 *   The existing name value.
 * @param $node_id
 *   The node ID.
 *
 * @return
 *   The fully-themed HTML output for the wrapped "name" pseudo-field.
 */
function edit_node_wrap_name($name, $node_id, $language, $view_mode) {
  return theme('edit_spanned_field', array(
    'value' => $name,
    'edit_id' => "node/$node_id/author/$language/$view_mode",
  ));
}

/**
 * Wraps the "date" pseudo-field attached to nodes.
 *
 * @param $date
 *   The existing date value.
 * @param $node_id
 *   The node ID.
 *
 * @return
 *   The fully-themed HTML output for the wrapped "date" pseudo-field.
 */
function edit_node_wrap_date($date, $node_id, $language, $view_mode) {
  return theme('edit_spanned_field', array(
    'value' => $date,
    'edit_id' => "node/$node_id/created/$language/$view_mode",
  ));
}

/**
 * Wraps the "title" pseudo-field for a page.
 *
 * @param $title
 *   The existing date value.
 * @param $label
 *   The Label name for the content type.
 * @param $node_id
 *   The node ID.
 *
 * @return
 *   The fully-themed HTML output for the wrapped "date" pseudo-field.
 */
function edit_page_title_render($title, $label, $node_id, $language = LANGUAGE_NONE) {
  return theme('edit_spanned_field', array(
    'value' => $title,
    'edit_id' => 'node/' . $node_id . '/title/' . $language . '/full',
  ));
}

/**
 * Renders the author and created date pseudo-fields.
 */
function edit_node_render_submitted($author, $created, $language, $view_mode) {
  // @todo Consider using template_preprocess_node() or theme_preprocess_node()
  // instead so this may be more easily overridden.
  return t('Submitted by !username on !datetime', array(
    '!username' => $author,
    '!datetime' => $created
  ));
}

/**
 * Implements hook_preprocess_field().
 */
function edit_preprocess_field(&$variables) {
  $element = $variables['element'];

  $entity_type = $element['#entity_type'];
  $field_name = $element['#field_name'];
  $language = $element['#language'];
  $view_mode = $element['#view_mode'];
  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $element['#object']);

  // Provide metadata through data- attributes.
  $variables['attributes_array']['data-edit-id'] = "$entity_type/$id/$field_name/$language/$view_mode";
}
